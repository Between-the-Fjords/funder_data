---
title: "Root traits operator bias: method, results and correction"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    embed-resources: true
execute:
  message: false
---

## Aim

Root trait data (`root_traits_clean`) are produced by several operators (winRhIZO scans and manual measurements). When plotting traits by operator, operator differences can be larger than treatment or site differences, which can obscure ecological effects. This document (1) quantifies how much variance is due to operator vs site and treatment, (2) shows where the bias appears, and (3) applies a correction so downstream analyses can use operator-adjusted values.

## Method

**Variance decomposition.** For each trait we fit three linear models:

- *Operator only:* `trait ~ operator` — how much variance operator explains alone.
- *Site × treatment:* `trait ~ siteID * treatment` — site, treatment, and their interaction (treatment nested within site).
- *Full:* `trait ~ siteID * treatment + operator` — site × treatment plus additive operator (operator is not nested in site/treatment).

We report R² for each model and the **partial R² for operator** (increase in R² when adding operator to site × treatment). If partial R² for operator is large, operator bias is substantial relative to ecological structure.

**Operator effects.** From the full model we report the estimated effect of each operator relative to a reference level (Michaela). These are the systematic offsets we will remove in the correction.

**Correction (subset-based approach).** We estimate each operator's effect **only from treatments where both that operator and the reference (Michaela) measured**. This avoids extrapolation and confounding between operator and treatment. For the reference operator, values are unchanged. For each other operator, we fit `trait ~ siteID * treatment + operator` on the shared-treatment subset, obtain their effect, and set **corrected = raw − effect**. Stored in `<trait>_corrected`. Rows with excluded operators (e.g. Peter) or without operator get `NA`. The pipeline applies this via `apply_operator_correction()` in `R/functions/correct_operator_bias.R`.

**How the correction is calculated (detail).**

1. **Choose the reference operator.** Michaela is used as reference (most complete coverage across treatments). Her values are left uncorrected.

2. **For each other operator:** Find treatments where both that operator and Michaela have non-missing trait values. Subset the data to those treatments and those two operators only.

3. **Fit the model on the subset.** Fit `trait ~ siteID * treatment + operator` with reference operator as baseline. The coefficient for the other operator is their estimated offset relative to Michaela.

4. **Apply correction.** For each row measured by that operator: corrected = raw − estimated_effect. For Michaela's rows: corrected = raw.

5. **Store.** The corrected value is written to `<trait>_corrected`. Operators with insufficient overlap (e.g. fewer than 5 rows in shared treatments) get `NA` in `*_corrected`.


## Data

We use `root_traits_clean` from the targets pipeline. We restrict to rows with non-missing operator and exclude operators listed in `OPERATORS_EXCLUDE` (Peter). Treatment is ordered for plotting.

```{r}
#| label: setup
#| message: false
suppressPackageStartupMessages(library(tidyverse))

# Load root traits from pipeline (run after tar_make() and loading targets)
if (!exists("root_traits_clean")) {
  if (requireNamespace("targets", quietly = TRUE)) {
    targets::tar_load(root_traits_clean)
  } else {
    stop("root_traits_clean not found. Run targets and load root_traits_clean.")
  }
}

OPERATORS_EXCLUDE <- c("Peter")
TRAIT_COLS <- c(
  "dry_root_biomass_g",
  "root_length_m",
  "average_root_diameter_m",
  "specific_root_length_m_per_g",
  "root_tissue_density_g_per_m3",
  "root_dry_matter_content",
  "root_productivity_g_per_m3_per_year"
)
# Display names for tables and figures
TRAIT_LABELS <- c(
  dry_root_biomass_g = "Root biomass (g)",
  root_length_m = "Root length (m)",
  average_root_diameter_m = "Average root diameter (m)",
  specific_root_length_m_per_g = "Specific root length (m/g)",
  root_tissue_density_g_per_m3 = "Root tissue density (g/m³)",
  root_dry_matter_content = "Root dry matter content",
  root_productivity_g_per_m3_per_year = "Root productivity (g/m³/year)"
)

op_col <- intersect(c("operator", "Operator"), names(root_traits_clean))[1]
if (is.na(op_col)) stop("No operator/Operator column in root_traits_clean.")
if (op_col == "Operator") root_traits_clean$operator <- root_traits_clean$Operator

dat <- root_traits_clean %>%
  filter(!is.na(operator)) %>%
  filter(!(operator %in% OPERATORS_EXCLUDE)) %>%
  mutate(
    treatment = factor(treatment, levels = c("C", "G", "F", "B", "FB", "GB", "GF", "FGB")),
    operator = factor(operator)
  )

run_operator_analysis <- nlevels(dat$operator) >= 2L
# Use Michaela as reference (most complete coverage); fallback to first alphabetically
ref_operator <- if (run_operator_analysis) {
  if ("Michaela" %in% levels(dat$operator)) "Michaela" else levels(dat$operator)[1]
} else NA_character_
# Set reference level so model coefficients are "effect vs reference"; reference operator then has no row in effects table
dat <- dat %>% mutate(operator = relevel(operator, ref = ref_operator))
```

## Results

### Operator sample sizes and coverage

```{r}
#| label: tbl-operator-summary
operator_summary <- dat %>%
  count(operator, name = "n_plots") %>%
  mutate(operator = as.character(operator))

operator_by_site <- dat %>%
  count(operator, siteID) %>%
  pivot_wider(names_from = operator, values_from = n, values_fill = 0)

operator_by_treatment <- dat %>%
  count(operator, treatment, .drop = FALSE) %>%
  pivot_wider(names_from = operator, values_from = n, values_fill = 0)

knitr::kable(operator_summary, caption = "Number of plots per operator (Peter excluded).")
knitr::kable(operator_by_site, caption = "Operator × site (counts).")
knitr::kable(operator_by_treatment, caption = "Operator × treatment (counts).")
```

### Variance decomposition (R²)

For each trait we compare how much variance is explained by operator alone, by site × treatment, and by the full model. The last column is the **partial R² for operator** (extra variance when adding operator to site × treatment).

```{r}
#| label: tbl-variance-decomp
if (run_operator_analysis) {
  variance_decomp <- function(trait_name) {
    form_op   <- as.formula(paste(trait_name, "~ operator"))
    form_st   <- as.formula(paste(trait_name, "~ siteID * treatment"))
    form_full <- as.formula(paste(trait_name, "~ siteID * treatment + operator"))
    d <- dat %>% filter(!is.na(.data[[trait_name]]))
    if (nrow(d) < 10L) return(NULL)
    m_op   <- lm(form_op,   data = d)
    m_st   <- lm(form_st,   data = d)
    m_full <- lm(form_full, data = d)
    tibble(
      trait = trait_name,
      n = nrow(d),
      R2_operator_only = summary(m_op)$r.squared,
      R2_site_treatment = summary(m_st)$r.squared,
      R2_full = summary(m_full)$r.squared,
      R2_partial_operator = summary(m_full)$r.squared - summary(m_st)$r.squared
    )
  }
  var_table <- TRAIT_COLS %>%
    map_dfr(variance_decomp) %>%
    filter(!is.na(R2_full)) %>%
    mutate(
      trait = unname(TRAIT_LABELS[trait]),
      R2_partial_operator_pct = 100 * R2_partial_operator
    ) %>%
    select(trait, n, R2_operator_only, R2_site_treatment, R2_full, R2_partial_operator, R2_partial_operator_pct)
  knitr::kable(
    var_table %>% rename(
      Trait = trait,
      `R² operator only` = R2_operator_only,
      `R² site × treatment` = R2_site_treatment,
      `R² full` = R2_full,
      `Partial R² operator` = R2_partial_operator,
      `Partial R² operator (%)` = R2_partial_operator_pct
    ),
    digits = 3,
    caption = "Variance decomposition (R²). Models: site × treatment (nested); full = site × treatment + operator. Partial R² for operator = R2_full - R2_site_treatment; (%) = × 100."
  )
} else {
  var_table <- tibble()
  knitr::kable(tibble(message = "Only one operator level; variance decomposition skipped."))
}
```

**Interpretation:** If `R2_partial_operator` is large for a trait, operator explains substantial variance beyond site and treatment, so correction is useful for that trait.

### Measurement consistency: Michaela's variability across conditions

To assess whether the reference operator (Michaela) measures consistently, we examine her measurement variability across treatments and sites. If Michaela's coefficient of variation (CV = SD/mean) is similar across conditions, she is a stable reference.

**Michaela's variability by treatment:**

```{r}
#| label: tbl-operator-variability-by-treatment
if (run_operator_analysis && "dry_root_biomass_g" %in% names(dat)) {
  # Calculate summary statistics by operator and treatment
  operator_variability <- dat %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    group_by(operator, treatment) %>%
    summarise(
      n = n(),
      mean = mean(dry_root_biomass_g),
      sd = sd(dry_root_biomass_g),
      cv = sd(dry_root_biomass_g) / mean(dry_root_biomass_g),
      .groups = "drop"
    ) %>%
    filter(n >= 3)  # Only show combinations with at least 3 observations
  
  # Focus on Michaela
  michaela_variability <- operator_variability %>%
    filter(operator == ref_operator) %>%
    select(treatment, n, mean, sd, cv)
  
  knitr::kable(
    michaela_variability,
    digits = 3,
    caption = paste0(ref_operator, "'s measurement variability by treatment for dry root biomass.")
  )
}
```

**Michaela's variability by site:**

```{r}
#| label: tbl-operator-variability-by-site
if (run_operator_analysis && "dry_root_biomass_g" %in% names(dat)) {
  # Same analysis by site
  operator_variability_site <- dat %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    group_by(operator, siteID) %>%
    summarise(
      n = n(),
      mean = mean(dry_root_biomass_g),
      sd = sd(dry_root_biomass_g),
      cv = sd(dry_root_biomass_g) / mean(dry_root_biomass_g),
      .groups = "drop"
    ) %>%
    filter(n >= 3)
  
  michaela_variability_site <- operator_variability_site %>%
    filter(operator == ref_operator) %>%
    select(siteID, n, mean, sd, cv)
  
  knitr::kable(
    michaela_variability_site,
    digits = 3,
    caption = paste0(ref_operator, "'s measurement variability by site for dry root biomass. If CV is similar across sites, measurement consistency is good.")
  )
}
```

**Interpretation:** Most of the CVs are ranging from 0.4-0.5 indicating moderate variability (typical for biological data). CVs of 0.6-0.8 suggest higher variability.


### Testing for treatment × operator interaction (within subsets)

The subset-based correction assumes operator effects are constant across treatments **within each operator pair**. We test this by running the interaction test **only on the subsets** where we actually estimate effects: for each operator pair (reference vs. other), subset to shared treatments, fit additive vs. interaction model, and compare AIC. If the interaction model fits better (ΔAIC < -2) in any subset, operator effects vary by treatment there, suggesting treatment-specific corrections might be needed.

```{r}
#| label: tbl-test-treatment-operator-interaction
if (run_operator_analysis && "dry_root_biomass_g" %in% names(dat)) {
  other_operators <- setdiff(levels(dat$operator), ref_operator)
  trait_test <- "dry_root_biomass_g"
  
  interaction_test_results <- tibble(
    operator_pair = character(),
    n = integer(),
    AIC_additive = numeric(),
    AIC_interaction = numeric(),
    delta_AIC = numeric(),
    interaction_better = logical()
  )
  
  for (op in other_operators) {
    op_treatments <- dat %>% filter(operator == op, !is.na(.data[[trait_test]])) %>% pull(treatment) %>% unique()
    ref_treatments <- dat %>% filter(operator == ref_operator, !is.na(.data[[trait_test]])) %>% pull(treatment) %>% unique()
    shared <- intersect(op_treatments, ref_treatments)
    if (length(shared) < 2) next  # Need at least 2 treatments to test interaction
    
    subset_data <- dat %>%
      filter(treatment %in% shared, operator %in% c(op, ref_operator), !is.na(.data[[trait_test]])) %>%
      mutate(operator = relevel(operator, ref = ref_operator))
    
    if (nrow(subset_data) < 10) next
    
    m_add <- tryCatch(lm(as.formula(paste(trait_test, "~ siteID * treatment + operator")), data = subset_data), error = function(e) NULL)
    m_int <- tryCatch(lm(as.formula(paste(trait_test, "~ siteID * treatment + treatment:operator")), data = subset_data), error = function(e) NULL)
    
    if (is.null(m_add) || is.null(m_int)) next
    
    aic_add <- AIC(m_add)
    aic_int <- AIC(m_int)
    delta <- aic_int - aic_add  # negative = interaction better
    
    interaction_test_results <- bind_rows(
      interaction_test_results,
      tibble(
        operator_pair = paste(ref_operator, "vs", op),
        n = nrow(subset_data),
        AIC_additive = round(aic_add, 1),
        AIC_interaction = round(aic_int, 1),
        delta_AIC = round(delta, 1),
        interaction_better = delta < -2
      )
    )
  }
  
  knitr::kable(
    interaction_test_results %>% rename(
      `Operator pair` = operator_pair,
      N = n,
      `AIC (additive)` = AIC_additive,
      `AIC (interaction)` = AIC_interaction,
      `ΔAIC (int - add)` = delta_AIC,
      `Interaction better?` = interaction_better
    ),
    digits = 1,
    caption = "Treatment × operator interaction test within subsets. Each row: subset where both operators measured. ΔAIC < -2 means interaction model fits better; would suggest treatment-specific corrections."
  )
}
```

**Interpretation:** The model including an interaction term between treatment and operator does not seem to fit the data better than the additive model in any of the subsets. This suggests that we can use the additive model to estimate operator effects and apply a single correction per operator.

### Operator effects (subset-based, vs reference)

Estimated effect of each operator relative to the reference operator (`r ref_operator`). Effects are estimated only from treatments where both that operator and the reference measured. Positive = higher trait value than reference on average. The reference operator does not appear (effect = 0 by definition).

```{r}
#| label: tbl-operator-effects
if (run_operator_analysis) {
  subset_operator_effects <- function(data, trait_name, reference_operator) {
    other_operators <- setdiff(levels(data$operator), reference_operator)
    out <- tibble(trait = character(), operator = character(), effect_vs_reference = numeric(), 
                  treatments_used = character(), n = integer())
    for (op in other_operators) {
      op_treatments <- data %>% filter(operator == op, !is.na(.data[[trait_name]])) %>% pull(treatment) %>% unique()
      ref_treatments <- data %>% filter(operator == reference_operator, !is.na(.data[[trait_name]])) %>% pull(treatment) %>% unique()
      shared <- intersect(op_treatments, ref_treatments)
      if (length(shared) == 0) next
      subset_data <- data %>%
        filter(treatment %in% shared, operator %in% c(op, reference_operator), !is.na(.data[[trait_name]])) %>%
        mutate(operator = relevel(operator, ref = reference_operator))
      if (nrow(subset_data) < 5) next
      m <- tryCatch(lm(as.formula(paste(trait_name, "~ siteID * treatment + operator")), data = subset_data), error = function(e) NULL)
      if (is.null(m)) next
      coef_name <- paste0("operator", op)
      if (!coef_name %in% names(coef(m))) next
      out <- bind_rows(out, tibble(
        trait = trait_name, operator = op,
        effect_vs_reference = unname(coef(m)[coef_name]),
        treatments_used = paste(sort(shared), collapse = ", "),
        n = nrow(subset_data %>% filter(operator == op))
      ))
    }
    out
  }
  effects_table <- TRAIT_COLS %>%
    map_dfr(~ subset_operator_effects(dat, .x, ref_operator)) %>%
    mutate(trait = unname(TRAIT_LABELS[trait]))
  knitr::kable(
    effects_table %>% rename(Trait = trait, Operator = operator, `Effect vs reference` = effect_vs_reference, `Treatments used` = treatments_used, N = n),
    digits = 4,
    caption = paste0("Operator effects vs reference (subset-based): ", ref_operator)
  )
} else {
  effects_table <- tibble()
}
```

### Plots: operator bias

**Traits by operator.** Boxplots of key traits by operator. There are systematic shifts between operators indicating a measurable bias.

```{r}
#| label: fig-plot-by-operator
#| fig-cap: "Root traits by operator (Peter excluded)."
#| fig-height: 8
if (run_operator_analysis) {
  traits_for_plot <- intersect(
    c("dry_root_biomass_g", "root_length_m", "average_root_diameter_m",
      "specific_root_length_m_per_g", "root_productivity_g_per_m3_per_year"),
    names(dat)
  )
  dat %>%
    select(siteID, blockID, plotID, treatment, operator, any_of(traits_for_plot)) %>%
    pivot_longer(any_of(traits_for_plot), names_to = "trait", values_to = "value") %>%
    filter(!is.na(value)) %>%
    mutate(trait_label = if_else(trait %in% names(TRAIT_LABELS), unname(TRAIT_LABELS[trait]), trait)) %>%
    ggplot(aes(x = operator, y = value, fill = operator)) +
    geom_boxplot(alpha = 0.8, outlier.alpha = 0.5) +
    facet_wrap(vars(trait_label), scales = "free_y", ncol = 2) +
    theme_bw() +
    theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Root traits by operator", x = "Operator", y = "Value")
}
```

**Dry root biomass by treatment and operator.** There are visible differences among operators. The difference between treatments is not so clear from visual inspection.

```{r}
#| label: fig-plot-treatment-operator
#| fig-cap: "Dry root biomass by treatment and operator."
#| fig-height: 5
if (run_operator_analysis) {
  dat %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    ggplot(aes(x = treatment, y = dry_root_biomass_g, fill = operator)) +
    geom_boxplot(position = position_dodge(0.8), alpha = 0.8, outlier.alpha = 0.5) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "Treatment", y = "Dry root biomass (g)")
}
```

**Dry root biomass by site and operator.** Similarly, large operator differences. The differences between sites are less visible.

```{r}
#| label: fig-plot-site-operator
#| fig-cap: "Dry root biomass by site and operator."
#| fig-height: 5
if (run_operator_analysis) {
  dat %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    ggplot(aes(x = siteID, y = dry_root_biomass_g, fill = operator)) +
    geom_boxplot(position = position_dodge(0.8), alpha = 0.8, outlier.alpha = 0.5) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "Site", y = "Dry root biomass (g)")
}
```

### Correction: raw vs corrected

We apply the subset-based correction: for each operator, the effect is estimated from shared treatments with the reference, then corrected = raw − effect. The plot below compares raw vs corrected dry root biomass. Points on the dashed line would be unchanged; systematic shifts off the line show the correction (e.g. if an operator systematically over- or under-estimates, their points move toward the line after correction).

```{r}
#| label: correction
if (run_operator_analysis) {
  # Subset-based correction (same logic as apply_operator_correction in correct_operator_bias.R)
  apply_operator_correction_local <- function(data, trait_names, reference_operator = NULL) {
    if (is.null(reference_operator)) reference_operator <- levels(data$operator)[1]
    has_op <- !is.na(data$operator) & !(data$operator %in% OPERATORS_EXCLUDE)
    other_operators <- setdiff(levels(data$operator), reference_operator)
    out <- data
    for (tr in trait_names) {
      if (!tr %in% names(data)) next
      corr_name <- paste0(tr, "_corrected")
      out[[corr_name]] <- NA_real_
      ref_idx <- which(has_op & data$operator == reference_operator & !is.na(data[[tr]]))
      out[[corr_name]][ref_idx] <- data[[tr]][ref_idx]
      for (op in other_operators) {
        op_idx <- which(has_op & data$operator == op & !is.na(data[[tr]]))
        if (length(op_idx) == 0) next
        op_treatments <- unique(data$treatment[op_idx])
        ref_treatments <- unique(data$treatment[has_op & data$operator == reference_operator & !is.na(data[[tr]])])
        shared <- intersect(op_treatments, ref_treatments)
        if (length(shared) == 0) next
        subset_data <- data %>%
          filter(treatment %in% shared, operator %in% c(op, reference_operator), !is.na(.data[[tr]])) %>%
          mutate(operator = relevel(operator, ref = reference_operator))
        if (nrow(subset_data) < 5) next
        m <- tryCatch(lm(as.formula(paste(tr, "~ siteID * treatment + operator")), data = subset_data), error = function(e) NULL)
        if (is.null(m)) next
        coef_name <- paste0("operator", op)
        if (!coef_name %in% names(coef(m))) next
        op_effect <- coef(m)[coef_name]
        out[[corr_name]][op_idx] <- data[[tr]][op_idx] - op_effect
      }
    }
    out
  }
  traits_to_correct <- intersect(TRAIT_COLS, names(dat))
  dat_corrected <- apply_operator_correction_local(dat, traits_to_correct, reference_operator = ref_operator)
}
```

```{r}
#| label: fig-plot-raw-vs-corrected
#| fig-cap: "Raw vs operator-corrected dry root biomass. Corrected to reference operator."
#| fig-height: 5
if (run_operator_analysis && "dry_root_biomass_g_corrected" %in% names(dat_corrected)) {
  dat_corrected %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    ggplot(aes(x = dry_root_biomass_g, y = dry_root_biomass_g_corrected, colour = operator)) +
    geom_abline(slope = 1, intercept = 0, linetype = 2, colour = "gray50") +
    geom_point(alpha = 0.8) +
    theme_bw() +
    labs(
      subtitle = paste0("Reference operator: ", ref_operator),
      x = "Raw (g)", y = "Corrected (g)"
    )
}
```

### Uncorrected vs corrected: treatment on x-axis

For dry root biomass we compare uncorrected values to values corrected using Michaela as reference. Below, **treatment is on the x-axis** and dry root biomass on the y-axis. Each panel shows one correction type (Uncorrected or Corrected with Michaela as reference); within each panel, points/boxes are coloured by the operator who actually measured. If the correction reduces operator bias, the spread between operators within each treatment should be smaller in the corrected panel than in the uncorrected panel.

```{r}
#| label: fig-correction-by-reference
#| fig-cap: "Dry root biomass by treatment: uncorrected and corrected to Michaela. Colour = operator who measured."
#| fig-height: 5
if (run_operator_analysis) {
  trait_one <- "dry_root_biomass_g"
  # Uncorrected
  long_correction <- dat %>%
    filter(!is.na(.data[[trait_one]])) %>%
    transmute(siteID, treatment, operator, value = .data[[trait_one]], correction_type = "Uncorrected")
  # Corrected with Michaela as reference
  d_corr <- apply_operator_correction_local(dat, trait_one, reference_operator = ref_operator)
  idx <- which(!is.na(dat[[trait_one]]))
  long_correction <- bind_rows(
    long_correction,
    d_corr %>% slice(idx) %>% transmute(siteID, treatment, operator, value = .data[[paste0(trait_one, "_corrected")]], correction_type = paste0("Corrected (reference: ", ref_operator, ")"))
  )
  correction_order <- c("Uncorrected", paste0("Corrected (reference: ", ref_operator, ")"))
  long_correction <- long_correction %>%
    mutate(correction_type = factor(correction_type, levels = correction_order))
  # Treatment on x-axis, dry mass on y-axis, faceted by correction type, coloured by operator
  ggplot(long_correction, aes(x = treatment, y = value, fill = operator)) +
    geom_boxplot(position = position_dodge(0.8), alpha = 0.8, outlier.alpha = 0.5) +
    facet_wrap(vars(correction_type), ncol = 2) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "Treatment", y = "Dry root biomass (g)", fill = "Operator who measured", title = "Treatment vs dry root biomass: uncorrected and corrected to Michaela")
}
```

## Effect of correction on treatment analysis

We fit the mixed model **dry root biomass ~ treatment + (1|siteID)** once with raw values and once with operator-corrected values (corrected to **Michaela** as reference operator), to see how the correction affects the treatment effect and model statistics.

```{r}
#| label: model-comparison
if (run_operator_analysis && exists("apply_operator_correction_local")) {
  suppressPackageStartupMessages({
    library(lme4)
    library(lmerTest)
    library(emmeans)
  })
  ref_operator_analysis <- "Michaela"
  dat_corrected_michaela <- apply_operator_correction_local(dat, "dry_root_biomass_g", reference_operator = ref_operator_analysis)
  d_model <- dat_corrected_michaela %>%
    filter(!is.na(dry_root_biomass_g), !is.na(dry_root_biomass_g_corrected))
  m_raw       <- lmer(dry_root_biomass_g ~ treatment + (1|siteID), data = d_model)
  m_corrected <- lmer(dry_root_biomass_g_corrected ~ treatment + (1|siteID), data = d_model)
}
```

### Model: raw dry root biomass ~ treatment + (1|siteID)

```{r}
#| label: tbl-model-raw
if (run_operator_analysis && exists("m_raw")) {
  fix_raw <- as.data.frame(coef(summary(m_raw)))
  fix_raw <- fix_raw %>% mutate(term = rownames(fix_raw), .before = 1)
  emm_raw <- as.data.frame(emmeans::emmeans(m_raw, ~ treatment))
  emm_raw <- emm_raw %>% select(treatment, emmean, SE, df, lower.CL, upper.CL)
  re_raw <- as.data.frame(VarCorr(m_raw)) %>% select(grp, var1, vcov, sdcor)
  knitr::kable(fix_raw, digits = 4, caption = "Fixed effects: raw dry root biomass", col.names = c("Term", "Estimate", "Std. Error", "df", "t value", "Pr(>|t|)"))
  #knitr::kable(emm_raw, digits = 4, caption = "Estimated marginal means by treatment: raw model")
}
```

### Model: corrected dry root biomass ~ treatment + (1|siteID)

Corrected values use **Michaela** as the reference operator.

```{r}
#| label: tbl-model-corrected
if (run_operator_analysis && exists("m_corrected")) {
  fix_corr <- as.data.frame(coef(summary(m_corrected)))
  fix_corr <- fix_corr %>% mutate(term = rownames(fix_corr), .before = 1)
  emm_corr <- as.data.frame(emmeans::emmeans(m_corrected, ~ treatment))
  emm_corr <- emm_corr %>% select(treatment, emmean, SE, df, lower.CL, upper.CL)
  re_corr <- as.data.frame(VarCorr(m_corrected)) %>% select(grp, var1, vcov, sdcor)
  knitr::kable(fix_corr, digits = 4, caption = "Fixed effects: corrected dry root biomass (reference: Michaela)", col.names = c("Term", "Estimate", "Std. Error", "df", "t value", "Pr(>|t|)"))
  #knitr::kable(emm_corr, digits = 4, caption = "Estimated marginal means by treatment: corrected model")
}
```
