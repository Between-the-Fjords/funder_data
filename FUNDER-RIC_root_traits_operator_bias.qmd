---
title: "Root traits operator bias: method, results and correction"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    embed-resources: true
execute:
  message: false
---

## Aim

Root trait data (`root_traits_clean`) are produced by several operators (winRhIZO scans and manual measurements). When plotting traits by operator, operator differences can be larger than treatment or site differences, which can obscure ecological effects. This document (1) quantifies how much variance is due to operator vs site and treatment, (2) shows where the bias appears, and (3) applies a correction so downstream analyses can use operator-adjusted values.

## Method

**Variance decomposition.** For each trait we fit three linear models:

- *Operator only:* `trait ~ operator` — how much variance operator explains alone.
- *Site × treatment:* `trait ~ siteID * treatment` — site, treatment, and their interaction (treatment nested within site).
- *Full:* `trait ~ siteID * treatment + operator` — site × treatment plus additive operator (operator is not nested in site/treatment).

We report R² for each model and the **partial R² for operator** (increase in R² when adding operator to site × treatment). If partial R² for operator is large, operator bias is substantial relative to ecological structure.

**Operator effects.** From the full model we report the estimated effect of each operator relative to a reference level (first alphabetically). These are the systematic offsets we will remove in the correction.

**Correction.** We define the corrected value as the **predicted value from the full model (site × treatment + operator) with operator set to the reference**. So for each row we ask: "What would the trait value be if this plot had been measured by the reference operator?" That predicted value is stored as `<trait>_corrected`. Rows with excluded operators (e.g. Peter) or without operator get `NA` in `*_corrected`. The pipeline target `root_traits_clean_corrected` applies this correction via `apply_operator_correction()` in `R/functions/correct_operator_bias.R`.

**How the correction is calculated (detail).**

1. **Fit the model.** For each trait we fit the linear model `trait ~ siteID * treatment + operator` on the analysis data (rows with non-missing operator, excluding operators in `OPERATORS_EXCLUDE`). This model estimates the effect of site, treatment, their interaction, and operator (additive). The operator effect is the systematic offset of each operator relative to a reference level.

2. **Choose the reference operator.** The reference operator is the level to which we "correct" all values — we answer: "What would the value be if the reference operator had measured this plot?" Here we use the first operator level alphabetically (e.g. "Lou"); you can pass a different `reference_operator` in `apply_operator_correction()`.

3. **Predict with operator = reference.** For each row we keep the observed `siteID` and `treatment` (and thus the same site × treatment effect), but we **replace the operator with the reference operator** in the prediction. So we construct a "new" row: same site, same treatment, operator = reference. We then call `predict(model, newdata = that_row)`. That predicted value is the **corrected** value: it is the expected trait value for that plot if the reference operator had measured it. It removes the estimated operator offset (e.g. if operator "Lucas" had a +0.5 g effect, the corrected value is 0.5 g lower for Lucas rows).

4. **Store.** The corrected value is written to `<trait>_corrected`. Rows that were not used in the model (no operator, or excluded operator) get `NA` in `*_corrected`.

**Excluded operators.** Operators with very few observations (e.g. one) cannot contribute a meaningful operator effect and can distort estimates. We exclude them from fitting and from the analysis sample; here we exclude Peter (one observation).

## Data

We use `root_traits_clean` from the targets pipeline. We restrict to rows with non-missing operator and exclude operators listed in `OPERATORS_EXCLUDE` (Peter). Treatment is ordered for plotting.

```{r}
#| label: setup
#| message: false
suppressPackageStartupMessages(library(tidyverse))

# Load root traits from pipeline (run after tar_make() and loading targets)
if (!exists("root_traits_clean")) {
  if (requireNamespace("targets", quietly = TRUE)) {
    targets::tar_load(root_traits_clean)
  } else {
    stop("root_traits_clean not found. Run targets and load root_traits_clean.")
  }
}

OPERATORS_EXCLUDE <- c("Peter")
TRAIT_COLS <- c(
  "dry_root_biomass_g",
  "root_length_m",
  "average_root_diameter_m",
  "specific_root_length_m_per_g",
  "root_tissue_density_g_per_m3",
  "root_dry_matter_content",
  "root_productivity_g_per_m3_per_year"
)
# Display names for tables and figures
TRAIT_LABELS <- c(
  dry_root_biomass_g = "Root biomass (g)",
  root_length_m = "Root length (m)",
  average_root_diameter_m = "Average root diameter (m)",
  specific_root_length_m_per_g = "Specific root length (m/g)",
  root_tissue_density_g_per_m3 = "Root tissue density (g/m³)",
  root_dry_matter_content = "Root dry matter content",
  root_productivity_g_per_m3_per_year = "Root productivity (g/m³/year)"
)

op_col <- intersect(c("operator", "Operator"), names(root_traits_clean))[1]
if (is.na(op_col)) stop("No operator/Operator column in root_traits_clean.")
if (op_col == "Operator") root_traits_clean$operator <- root_traits_clean$Operator

dat <- root_traits_clean %>%
  filter(!is.na(operator)) %>%
  filter(!(operator %in% OPERATORS_EXCLUDE)) %>%
  mutate(
    treatment = factor(treatment, levels = c("C", "G", "F", "B", "FB", "GB", "GF", "FGB")),
    operator = factor(operator)
  )

run_operator_analysis <- nlevels(dat$operator) >= 2L
ref_operator <- if (run_operator_analysis) levels(dat$operator)[1] else NA_character_
```

## Results

### Operator sample sizes and coverage

```{r}
#| label: tbl-operator-summary
operator_summary <- dat %>%
  count(operator, name = "n_plots") %>%
  mutate(operator = as.character(operator))

operator_by_site <- dat %>%
  count(operator, siteID) %>%
  pivot_wider(names_from = operator, values_from = n, values_fill = 0)

operator_by_treatment <- dat %>%
  count(operator, treatment, .drop = FALSE) %>%
  pivot_wider(names_from = operator, values_from = n, values_fill = 0)

knitr::kable(operator_summary, caption = "Number of plots per operator (Peter excluded).")
knitr::kable(operator_by_site, caption = "Operator × site (counts).")
knitr::kable(operator_by_treatment, caption = "Operator × treatment (counts).")
```

### Variance decomposition (R²)

For each trait we compare how much variance is explained by operator alone, by site × treatment, and by the full model. The last column is the **partial R² for operator** (extra variance when adding operator to site × treatment).

```{r}
#| label: tbl-variance-decomp
if (run_operator_analysis) {
  variance_decomp <- function(trait_name) {
    form_op   <- as.formula(paste(trait_name, "~ operator"))
    form_st   <- as.formula(paste(trait_name, "~ siteID * treatment"))
    form_full <- as.formula(paste(trait_name, "~ siteID * treatment + operator"))
    d <- dat %>% filter(!is.na(.data[[trait_name]]))
    if (nrow(d) < 10L) return(NULL)
    m_op   <- lm(form_op,   data = d)
    m_st   <- lm(form_st,   data = d)
    m_full <- lm(form_full, data = d)
    tibble(
      trait = trait_name,
      n = nrow(d),
      R2_operator_only = summary(m_op)$r.squared,
      R2_site_treatment = summary(m_st)$r.squared,
      R2_full = summary(m_full)$r.squared,
      R2_partial_operator = summary(m_full)$r.squared - summary(m_st)$r.squared
    )
  }
  var_table <- TRAIT_COLS %>%
    map_dfr(variance_decomp) %>%
    filter(!is.na(R2_full)) %>%
    mutate(
      trait = unname(TRAIT_LABELS[trait]),
      R2_partial_operator_pct = 100 * R2_partial_operator
    ) %>%
    select(trait, n, R2_operator_only, R2_site_treatment, R2_full, R2_partial_operator, R2_partial_operator_pct)
  knitr::kable(
    var_table %>% rename(
      Trait = trait,
      `R² operator only` = R2_operator_only,
      `R² site × treatment` = R2_site_treatment,
      `R² full` = R2_full,
      `Partial R² operator` = R2_partial_operator,
      `Partial R² operator (%)` = R2_partial_operator_pct
    ),
    digits = 3,
    caption = "Variance decomposition (R²). Models: site × treatment (nested); full = site × treatment + operator. Partial R² for operator = R2_full - R2_site_treatment; (%) = × 100."
  )
} else {
  var_table <- tibble()
  knitr::kable(tibble(message = "Only one operator level; variance decomposition skipped."))
}
```

**Interpretation:** If `R2_partial_operator` is large for a trait, operator explains substantial variance beyond site and treatment, so correction is useful for that trait.

### Operator effects (coefficients vs reference)

Estimated effect of each operator relative to the reference operator (`r ref_operator`). Positive = higher trait value than reference on average (after accounting for site and treatment).

```{r}
#| label: tbl-operator-effects
if (run_operator_analysis) {
  operator_effects <- function(trait_name) {
    form <- as.formula(paste(trait_name, "~ siteID * treatment + operator"))
    d <- dat %>% filter(!is.na(.data[[trait_name]]))
    if (nrow(d) < 10L) return(NULL)
    m <- lm(form, data = d)
    co <- coef(m)
    op_coefs <- co[grepl("^operator", names(co))]
    tibble(
      trait = trait_name,
      operator = gsub("operator", "", names(op_coefs), fixed = TRUE),
      effect_vs_reference = unname(op_coefs)
    )
  }
  effects_table <- TRAIT_COLS %>%
    map_dfr(operator_effects) %>%
    filter(!is.na(effect_vs_reference)) %>%
    mutate(trait = unname(TRAIT_LABELS[trait]))
  knitr::kable(
    effects_table %>% rename(Trait = trait, Operator = operator, `Effect vs reference` = effect_vs_reference),
    digits = 4,
    caption = paste0("Operator effects vs reference: ", ref_operator)
  )
} else {
  effects_table <- tibble()
}
```

### Plots: operator bias

**Traits by operator.** Boxplots of key traits by operator. Systematic shifts between operators indicate measurable bias.

```{r}
#| label: fig-plot-by-operator
#| fig-cap: "Root traits by operator (Peter excluded)."
#| fig-height: 8
if (run_operator_analysis) {
  traits_for_plot <- intersect(
    c("dry_root_biomass_g", "root_length_m", "average_root_diameter_m",
      "specific_root_length_m_per_g", "root_productivity_g_per_m3_per_year"),
    names(dat)
  )
  dat %>%
    select(siteID, blockID, plotID, treatment, operator, any_of(traits_for_plot)) %>%
    pivot_longer(any_of(traits_for_plot), names_to = "trait", values_to = "value") %>%
    filter(!is.na(value)) %>%
    ggplot(aes(x = operator, y = value, fill = operator)) +
    geom_boxplot(alpha = 0.8, outlier.alpha = 0.5) +
    facet_wrap(vars(trait), scales = "free_y", ncol = 2) +
    theme_bw() +
    theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Root traits by operator", x = "Operator", y = "Value")
}
```

**Dry root biomass by treatment and operator.** If operator differences are visible within each treatment, bias is not confounded with treatment.

```{r}
#| label: fig-plot-treatment-operator
#| fig-cap: "Dry root biomass by treatment and operator."
#| fig-height: 5
if (run_operator_analysis) {
  dat %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    ggplot(aes(x = treatment, y = dry_root_biomass_g, fill = operator)) +
    geom_boxplot(position = position_dodge(0.8), alpha = 0.8, outlier.alpha = 0.5) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "Treatment", y = "Dry root biomass (g)")
}
```

**Dry root biomass by site and operator.** Similarly, operator differences within sites indicate operator bias rather than site structure.

```{r}
#| label: fig-plot-site-operator
#| fig-cap: "Dry root biomass by site and operator."
#| fig-height: 5
if (run_operator_analysis) {
  dat %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    ggplot(aes(x = siteID, y = dry_root_biomass_g, fill = operator)) +
    geom_boxplot(position = position_dodge(0.8), alpha = 0.8, outlier.alpha = 0.5) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "Site", y = "Dry root biomass (g)")
}
```

### Correction: raw vs corrected

We apply the correction as above: the full model is fitted, then for each row we predict using the same site and treatment but **operator set to the reference**; that prediction is the corrected value. The plot below compares raw vs corrected dry root biomass. Points on the dashed line would be unchanged; systematic shifts off the line show the correction (e.g. if an operator systematically over- or under-estimates, their points move toward the line after correction).

```{r}
#| label: correction
if (run_operator_analysis) {
  apply_operator_correction_local <- function(data, trait_names, reference_operator = NULL) {
    if (is.null(reference_operator)) reference_operator <- levels(data$operator)[1]
    out <- data
    for (tr in trait_names) {
      if (!tr %in% names(data)) next
      form <- as.formula(paste(tr, "~ siteID * treatment + operator"))
      d <- data %>% filter(!is.na(.data[[tr]]))
      if (nrow(d) < 10L) next
      m <- lm(form, data = d)
      newdata <- d %>% mutate(operator = factor(reference_operator, levels = levels(data$operator)))
      pred <- predict(m, newdata = newdata)
      corr_name <- paste0(tr, "_corrected")
      out[[corr_name]] <- NA_real_
      out[[corr_name]][which(!is.na(data[[tr]]))] <- pred
    }
    out
  }
  traits_to_correct <- intersect(TRAIT_COLS, names(dat))
  dat_corrected <- apply_operator_correction_local(dat, traits_to_correct, reference_operator = ref_operator)
}
```

```{r}
#| label: fig-plot-raw-vs-corrected
#| fig-cap: "Raw vs operator-corrected dry root biomass. Corrected to reference operator."
#| fig-height: 5
if (run_operator_analysis && "dry_root_biomass_g_corrected" %in% names(dat_corrected)) {
  dat_corrected %>%
    filter(!is.na(dry_root_biomass_g)) %>%
    ggplot(aes(x = dry_root_biomass_g, y = dry_root_biomass_g_corrected, colour = operator)) +
    geom_abline(slope = 1, intercept = 0, linetype = 2, colour = "gray50") +
    geom_point(alpha = 0.8) +
    theme_bw() +
    labs(
      subtitle = paste0("Reference operator: ", ref_operator),
      x = "Raw (g)", y = "Corrected (g)"
    )
}
```

### Uncorrected vs corrected: treatment on x-axis

For dry root biomass we apply the correction once per operator as reference (uncorrected + corrected with Lou, Lucas, etc.). Below, **treatment is on the x-axis** and dry root biomass on the y-axis. Each panel shows one correction type (Uncorrected, or Corrected with a given reference operator); within each panel, points/boxes are coloured by the operator who actually measured. If the correction reduces operator bias, the spread between operators within each treatment should be smaller in the corrected panels than in the Uncorrected panel.

```{r}
#| label: fig-correction-by-reference
#| fig-cap: "Dry root biomass by treatment: uncorrected and corrected by reference operator. Colour = operator who measured."
#| fig-height: 8
if (run_operator_analysis) {
  trait_one <- "dry_root_biomass_g"
  ref_operators <- levels(dat$operator)
  # Uncorrected
  long_correction <- dat %>%
    filter(!is.na(.data[[trait_one]])) %>%
    transmute(siteID, treatment, operator, value = .data[[trait_one]], correction_type = "Uncorrected")
  # Corrected for each reference operator
  for (ref_op in ref_operators) {
    d_corr <- apply_operator_correction_local(dat, trait_one, reference_operator = ref_op)
    idx <- which(!is.na(dat[[trait_one]]))
    long_correction <- bind_rows(
      long_correction,
      d_corr %>% slice(idx) %>% transmute(siteID, treatment, operator, value = .data[[paste0(trait_one, "_corrected")]], correction_type = paste0("Corrected (reference: ", ref_op, ")"))
    )
  }
  correction_order <- c("Uncorrected", paste0("Corrected (reference: ", ref_operators, ")"))
  long_correction <- long_correction %>%
    mutate(correction_type = factor(correction_type, levels = correction_order))
  # Treatment on x-axis, dry mass on y-axis, faceted by correction type, coloured by operator
  ggplot(long_correction, aes(x = treatment, y = value, fill = operator)) +
    geom_boxplot(position = position_dodge(0.8), alpha = 0.8, outlier.alpha = 0.5) +
    facet_wrap(vars(correction_type), ncol = 2) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "Treatment", y = "Dry root biomass (g)", fill = "Operator who measured", title = "Treatment vs dry root biomass: uncorrected and corrected by reference operator")
}
```

## Effect of correction on treatment analysis

We fit the mixed model **dry root biomass ~ treatment + (1|siteID)** once with raw values and once with operator-corrected values (corrected to **Michaela** as reference operator), to see how the correction affects the treatment effect and model statistics.

```{r}
#| label: model-comparison
if (run_operator_analysis && exists("apply_operator_correction_local")) {
  suppressPackageStartupMessages({
    library(lme4)
    library(lmerTest)
    library(emmeans)
  })
  ref_operator_analysis <- "Michaela"
  dat_corrected_michaela <- apply_operator_correction_local(dat, "dry_root_biomass_g", reference_operator = ref_operator_analysis)
  d_model <- dat_corrected_michaela %>%
    filter(!is.na(dry_root_biomass_g), !is.na(dry_root_biomass_g_corrected))
  m_raw       <- lmer(dry_root_biomass_g ~ treatment + (1|siteID), data = d_model)
  m_corrected <- lmer(dry_root_biomass_g_corrected ~ treatment + (1|siteID), data = d_model)
}
```

### Model: raw dry root biomass ~ treatment + (1|siteID)

```{r}
#| label: tbl-model-raw
if (run_operator_analysis && exists("m_raw")) {
  fix_raw <- as.data.frame(coef(summary(m_raw)))
  fix_raw <- fix_raw %>% mutate(term = rownames(fix_raw), .before = 1)
  emm_raw <- as.data.frame(emmeans::emmeans(m_raw, ~ treatment))
  emm_raw <- emm_raw %>% select(treatment, emmean, SE, df, lower.CL, upper.CL)
  re_raw <- as.data.frame(VarCorr(m_raw)) %>% select(grp, var1, vcov, sdcor)
  knitr::kable(fix_raw, digits = 4, caption = "Fixed effects: raw dry root biomass", col.names = c("Term", "Estimate", "Std. Error", "df", "t value", "Pr(>|t|)"))
  #knitr::kable(emm_raw, digits = 4, caption = "Estimated marginal means by treatment: raw model")
}
```

### Model: corrected dry root biomass ~ treatment + (1|siteID)

Corrected values use **Michaela** as the reference operator.

```{r}
#| label: tbl-model-corrected
if (run_operator_analysis && exists("m_corrected")) {
  fix_corr <- as.data.frame(coef(summary(m_corrected)))
  fix_corr <- fix_corr %>% mutate(term = rownames(fix_corr), .before = 1)
  emm_corr <- as.data.frame(emmeans::emmeans(m_corrected, ~ treatment))
  emm_corr <- emm_corr %>% select(treatment, emmean, SE, df, lower.CL, upper.CL)
  re_corr <- as.data.frame(VarCorr(m_corrected)) %>% select(grp, var1, vcov, sdcor)
  knitr::kable(fix_corr, digits = 4, caption = "Fixed effects: corrected dry root biomass (reference: Michaela)", col.names = c("Term", "Estimate", "Std. Error", "df", "t value", "Pr(>|t|)"))
  #knitr::kable(emm_corr, digits = 4, caption = "Estimated marginal means by treatment: corrected model")
}
```

## Discussion and recommendation

**Reasoning.**

- Operator bias is quantified by the partial R² for operator and by the operator-effect coefficients. If operator explains more variance than (or comparable to) site and treatment, correction is justified.
- Excluding operators with a single observation (e.g. Peter) avoids estimating a non-existent operator effect from one plot.
- The correction is model-based: we keep site × treatment structure (treatment nested in site) and remove the operator offset by predicting under the reference operator. No single scalar "correction factor" is applied; the adjustment is row-specific.

**Recommendation.**

1. Use the **variance decomposition table** to see which traits show non-negligible operator partial R²; focus correction on those traits in practice.
2. For downstream analyses (e.g. treatment or climate effects), use the **`*_corrected`** columns from `root_traits_clean_corrected` when operator bias is a concern.
3. The pipeline target `root_traits_clean_corrected` applies this correction via `apply_operator_correction()` in `R/functions/correct_operator_bias.R`, with Peter excluded by default.
4. Reference operator used here: **`r if (run_operator_analysis) ref_operator else "N/A (analysis skipped)"`**. To use a different reference, pass `reference_operator` to `apply_operator_correction()`.

**Reproducibility.** Render this Quarto document after running the targets pipeline and loading `root_traits_clean` (e.g. via `run.R` or `tar_load(root_traits_clean)`).
